---

layout: post
title: 스프링 부트에서 테스트 코드 작성
date: 2024-09-12 00:00:00 +0800
categories: [CS Study, testcode]
tags: [Sophomore, Testcode]
pin: true

---


### 1. 테스트 코드가 필요한 이유

- 빠른 피드백  
    기존의 개발 방식 다음과 같습니다.  
    1. 코드 작성
    2. 프로그램 실행
    3. API 테스트 도구(Postman 등)로 HTTP 요청(POST, GET, PUT 등등)
    4. 요청 결과를 눈으로 검증
    5. 결과가 의도대로 나오지 않으면, 다시 프로그램을 중지하고 코드 수정  

    이 과정에서 톰캣(서버)를 재시작 해야하는데, 규모가 큰 서버의 경우 서버를 껐다가 키는 것은 많은 시간을 소요하기 때문에 비효율적이다.


- 수동 검증 -> 자동 검증  
사람의 눈으로 검증(수동 검증)하지 않아도 되기 때문에 더 확실한 검증이 가능하다.


- 개발자가 만든 기능을 안전하게 보호  
하나의 기능을 수정했을 때, 나머지의 기능도 잘 동작되는지 확인하고, 서비스의 모든 기능을 보장해준다.

### 2. Hello Contorller 테스트 코드 작성하기  

책에서는 프로젝트를 생성한 뒤, Application 클래스를 만들어서 직접 코드를 작성하고 있지만,  
지금은 인텔리제이에서 프로젝트를 생성하면, Application 파일을 자동으로 만들어줍니다.  

- Application
```java
package com.example.spring_study;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // 스프링 부트 자동 설정과 Bean 관리
public class SpringStudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringStudyApplication.class, args);
    }
}
```  

<br>

- HelloController
```java
package com.example.spring_study.web;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}

```

![Alt text](image-2.png)

서버를 실행한 뒤, https://localhost:8080/hello를 접속하면 hello라는 글자가 정상적으로 출력됨을 확인할 수 있다.  

<br>

그렇다면 이제 이렇게 눈으로만 검증했던 이 helloController를 테스트 코드를 통해 검증해보자.  


```java
package com.example.spring_study.web;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


//@ExtendWith(SpringExtension.class) // JUnit5
//@WebMvcTest(HelloController.class)
@AutoConfigureMockMvc // web 계층 테스트를 할 수 있도록 자동 설정
@SpringBootTest // 애플리케이션 전체 컨텍스트를 로드
class HelloControllerTest {

    @Autowired
    private MockMvc mvc;

    @DisplayName("hello가 리턴된다.")
    @Test
    public void helloTest() throws Exception {
        String hello = "hello";

        mvc.perform(get("/hello"))
                .andExpect(status().isOk())
                .andExpect(content().string(hello));
    }
}
```

책에서는 

```java
@ExtendWith(SpringExtension.class) // JUnit5
@WebMvcTest(HelloController.class)
```

이렇게 @ExtendWith로 Spring Context를 불러오지만, 요즘에는 @SpringBootTest라는 어노테이션으로 전체 컨텍스트를 로드한다.  
만약 해당 컨트롤러만 독립적으로 테스트를 진행하고 싶다면, @WebMvcTest(HelloController.class)을 이용하면 되고, 통합적으로 테스트를 해보고싶다면, @SpringBootTest를 붙여주면 된다.  

<br>

위의 코드에 대해 자세히 설명해보자면, 다음과 같다.  

```java

// 서버를 실제로 배포하지 않고도, HTTP 요청을 만들어서 컨트롤러를 테스트할 수 있게 해주는 MockMvc 객체를 주입
@Autowired
private MockMvc mvc;


// 요즘 Junit에는 @DisplayName이 추가되어서, 테스트의 이름을 따로 명시할 수 있게 되어있음.
@DisplayName("hello가 리턴된다.")
@Test
public void helloTest() throws Exception {
    String hello = "hello";

    // mvc.perform(get("/hello")): 아까 주입해줬던 MockMvc를 통해 /hello로 get 요청을 보낸다.
    // status().isOk() : 그리고 그 요청의 결과가 성공적인지 검증하고,
    // content().string(hello) : 응답 본문이 hello인지 검증한다.
    mvc.perform(get("/hello"))
            .andExpect(status().isOk())
            .andExpect(content().string(hello));
}
```  


<br>
테스트 코드를 실행해보면, 아래와 같이 성공했음을 확인할 수 있다.  

![Alt text](image-3.png)  

### 3. 롬복 소개 및 설치하기  

롬복(Lombok)은 코드를 깔끔하게 보이기 위해서 사용되는 라이브러리이다.  
롬복을 이용하면, 클래스를 생성할 때 자주 사용하는 getter, setter, toString 등의 메서드를 자동으로 생성해준다.  

**설정 방법**  
아래와 같이 build.gradle 파일의 dependencies에 `compileOnly 'org.projectlombok:lombok'`를 추가해주면 된다. 
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
}
```

<br>

그리고 인텔리제이에서 Settings > Plugins로 이동해서 Lombok을 검색하고 설치한 뒤, 인텔리제이를 재시작한다. 

그리고 다시 Settings > Build, Execution, Deployment > Compiler > Annotation Processors로 이동해서 Enable annotation processing를 체크해야 Lombok이 제대로 동작한다.  

![Alt text](image-4.png)
