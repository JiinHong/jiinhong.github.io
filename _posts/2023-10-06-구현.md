---

layout: post
title: 구현
date: 2023-10-06 00:00:00 +0800
categories: [CS Study, algorithm]
tags: [Sophomore, CodingTest]
pin: true

---

### 구현

**풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제**  

<이코테>에서는 이 유형에서 완전 탐색과 시뮬레이션을 다루고 있는데, **완전 탐색**은 모든 경우의 수를 주저 없이 다 계산하는 해결 방법을 의미하고, **시뮬레이션**은 알고리즘을 한 단계씩 차례대로 직접 수행해야하는 문제이다.  

구현에서는 **채점 환경**을 고려하는 것이 중요하다. 특히 파이썬은 C/C++에 비해 동작 속도가 느리다. 일반적인 기업 코딩 테스트 환경에서는 파이썬으로 제출한 코드가 1초에 2000만 번의 계산을 수행한다고 가정하면 크게 무리가 없다.  
얼마 전에 사용자에게 정수 입력을 받고 제켄도르프 정리(Zeckendorf's Theorem)을 구현하는 알고리즘 과제를 풀었었는데, 그때 나의 코드가 Time Limit Exceeded이 떴다.  
  
  나의 코드
  ```python
  n = int(input())
n_first = n
i = 0
people = []
chicken = []
def fibo (n):
    if n <= 1:
        return n
    else:
        return fibo(n-1) + fibo(n-2)

while fibo(i) < n: # 가장 큰 피보나치 수 찾기
    i += 1
    if fibo(i) >= n:
        i -= 1
        people.append(fibo(i))
        chicken.append(fibo(i-1))
        chicken_index = i # 연속된 피보나치수는 안되기 때문에 인덱스를 저장해서 나중에 비교
        n = n - fibo(i) # 가장 큰 피보나치수 빼주기

while True: # 다 더하면 빠져나가기
    while fibo(i) > n: # 반복
        i -= 1
        if fibo(i) <= n and i != chicken_index:
            if i == 0:
                break
            people.append(fibo(i))
            chicken.append(fibo(i-1))
            chicken_index = i
            n = n - fibo(i)
            break
    if sum(people) == n_first:
        break

print(sum(chicken))
  ```  
  이 코드에서 피보나치 함수가 재귀 알고리즘을 사용하기 때문에 시간복잡도가 지수의 영향을 받아서 최종적으로 최악의 경우 시간복잡도가 $2^{log(n)}$가 된다. 따라서, 재귀 알고리즘을 쓰지 않고 구현해야만 했다.

```python
def fibonacci_sum(n):
    # 피보나치 수열 생성
    fibonacci = [0, 1]
    while fibonacci[-1] < n:
        fibonacci.append(fibonacci[-1] + fibonacci[-2]) # 최종적으로, n보다 큰 요소가 마지막에 들어감.

    # 피보나치 수열 중 n보다 작거나 같은 수를 찾아서 더하기
    result = 0
    i = len(fibonacci) - 2 # n보다 큰 요소 포함 안시키기 위함.
    while n > 0 and i >= 0:
        if fibonacci[i] <= n: # 빼고 남은 값(n)보다 작은 최대의 피보나치 수 구하기
            n -= fibonacci[i] # 피보나치수 빼주기
            result += fibonacci[i - 1]  # 치킨 개수 추가
        i -= 1

    return result

# 사용자로부터 입력 받음
n = int(input())

# 최종 결과 출력
print(fibonacci_sum(n))
```  
이렇게 하면 재귀 알고리즘이 쓰이지않기 때문에 시간복잡도가 지수의 영향을 받지 않는다. 둘 다 피보나치를 구하는 정상적인 알고리즘인데 이렇게 달라지는게 신기했다. `fibonacci.append(fibonacci[-1] + fibonacci[-2])`이 함수를 사용하는게 관건이었던 것 같다. 굳이 큰 수부터 재귀적으로 피보나치를 적용하지 않고, `fibonacci[-1]`를 이용하여 리스트 끝에 있는 요소를 불러올 수 있는 것이다.  
  
  이처럼, 구현을 할 때 **채점 환경**을 고려하여시간복잡도가 지수의 영향을 최대한 받지 않게 조심해야한다.